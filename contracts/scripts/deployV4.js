const hre = require("hardhat");
const fs = require("fs");
const path = require("path");

async function main() {
  const [deployer] = await hre.ethers.getSigners();
  console.log("Deploying with:", deployer.address);
  console.log("Network:", hre.network.name);

  // 1. Deploy MockUSDC
  console.log("\n1. Deploying MockUSDC...");
  const MockUSDC = await hre.ethers.getContractFactory("MockUSDC");
  const usdc = await MockUSDC.deploy();
  await usdc.waitForDeployment();
  const usdcAddress = await usdc.getAddress();
  console.log("   MockUSDC:", usdcAddress);

  // 2. Deploy PredictionMarketV4 (å‡çº§ç‰ˆï¼šæ”¯æŒ CPMM + LMSR åŒç®—æ³•)
  console.log("\n2. Deploying PredictionMarketV4...");
  const PredictionMarket = await hre.ethers.getContractFactory("PredictionMarketV4");
  const predictionMarket = await PredictionMarket.deploy(usdcAddress);
  await predictionMarket.waitForDeployment();
  const predictionAddress = await predictionMarket.getAddress();
  console.log("   PredictionMarketV4:", predictionAddress);

  // 3. Deploy CreatorMarketV3 (å‡çº§ç‰ˆï¼šæ”¯æŒå¤šæ›²çº¿ç±»åž‹)
  console.log("\n3. Deploying CreatorMarketV3...");
  const CreatorMarket = await hre.ethers.getContractFactory("CreatorMarketV3");
  const creatorMarket = await CreatorMarket.deploy(usdcAddress);
  await creatorMarket.waitForDeployment();
  const creatorAddress = await creatorMarket.getAddress();
  console.log("   CreatorMarketV3:", creatorAddress);

  // èŽ·å– Chain ID
  const network = await hre.ethers.provider.getNetwork();
  const chainId = Number(network.chainId);

  // 4. ä¿å­˜ deployed-addresses.json
  const addresses = {
    MockUSDC: usdcAddress,
    PredictionMarketV4: predictionAddress,
    CreatorMarketV3: creatorAddress,
    deployer: deployer.address,
    network: hre.network.name,
    chainId: chainId,
    timestamp: new Date().toISOString(),
    // æ–°å¢žï¼šè®°å½•åˆçº¦ç‰¹æ€§
    features: {
      predictionMarket: {
        version: 4,
        algorithms: ["CPMM", "LMSR"],
        description: "æ”¯æŒ CPMM å’Œ LMSR åŒå®šä»·ç®—æ³•"
      },
      creatorMarket: {
        version: 3,
        curveTypes: ["LINEAR", "EXPONENTIAL", "SIGMOID"],
        description: "æ”¯æŒçº¿æ€§ã€æŒ‡æ•°ã€Sigmoid ä¸‰ç§è”åˆæ›²çº¿"
      }
    }
  };

  fs.writeFileSync(
    "deployed-addresses.json",
    JSON.stringify(addresses, null, 2)
  );
  console.log("\nâœ… Saved deployed-addresses.json");

  // 5. è‡ªåŠ¨æ›´æ–°å‰ç«¯ config.ts
  const frontendConfigPath = path.join(__dirname, "../../frontend/src/constants/config.ts");
  
  const configContent = `// Auto-generated by deployV4.js - ${new Date().toISOString()}
// Network: ${hre.network.name} (Chain ID: ${chainId})

export const PREDICTION_MARKET_ADDRESS = "${predictionAddress}";
export const CREATOR_MARKET_ADDRESS = "${creatorAddress}";
export const USDC_ADDRESS = "${usdcAddress}";
export const CHAIN_ID = ${chainId};
export const CHAIN_NAME = "${hre.network.name}";

// USDC decimals
export const USDC_DECIMALS = 6;

// Contract versions
export const PREDICTION_MARKET_VERSION = 4;
export const CREATOR_MARKET_VERSION = 3;

// Prediction Market ç®—æ³•ç±»åž‹
export enum PricingAlgorithm {
  CPMM = 0,   // æ’å®šä¹˜ç§¯åšå¸‚å•†
  LMSR = 1    // å¯¹æ•°å¸‚åœºè¯„åˆ†è§„åˆ™
}

// Creator Market æ›²çº¿ç±»åž‹
export enum CurveType {
  LINEAR = 0,      // çº¿æ€§æ›²çº¿: price = A * supply + B
  EXPONENTIAL = 1, // æŒ‡æ•°æ›²çº¿: price = B + A * supplyÂ²
  SIGMOID = 2      // Såž‹æ›²çº¿: æ—©æœŸæ…¢ -> ä¸­æœŸå¿« -> åŽæœŸæ…¢
}

// é»˜è®¤æ›²çº¿å‚æ•°
export const DEFAULT_CURVE_A = 10000;        // 0.01 USDC æ–œçŽ‡
export const DEFAULT_CURVE_B = 1000000;      // 1 USDC åŸºç¡€ä»·æ ¼
export const DEFAULT_INFLECTION = 100;       // Sigmoid æ‹ç‚¹
export const DEFAULT_LMSR_B = "100000000000000000000"; // 100 * 10^18

// RPC URL (for reference)
export const RPC_URL = "${getRpcUrl(hre.network.name)}";
`;

  try {
    fs.writeFileSync(frontendConfigPath, configContent);
    console.log("âœ… Updated frontend/src/constants/config.ts");
  } catch (error) {
    console.log("âš ï¸ Could not update frontend config:", error.message);
  }

  // 6. è‡ªåŠ¨æ›´æ–° Oracle .env
  const oracleDir = path.join(__dirname, "../../oracle-node");
  
  if (!fs.existsSync(oracleDir)) {
    fs.mkdirSync(oracleDir, { recursive: true });
  }

  const oracleEnvPath = path.join(oracleDir, ".env");
  let existingPrivateKey = "ä½ çš„ç§é’¥";
  let existingRapidApiKey = "ä½ çš„RapidAPIå¯†é’¥";
  
  if (fs.existsSync(oracleEnvPath)) {
    const existingEnv = fs.readFileSync(oracleEnvPath, 'utf8');
    const privateKeyMatch = existingEnv.match(/PRIVATE_KEY=(.+)/);
    const rapidApiMatch = existingEnv.match(/RAPIDAPI_KEY=(.+)/);
    if (privateKeyMatch && privateKeyMatch[1] && !privateKeyMatch[1].includes('ä½ çš„')) {
      existingPrivateKey = privateKeyMatch[1];
    }
    if (rapidApiMatch && rapidApiMatch[1] && !rapidApiMatch[1].includes('ä½ çš„')) {
      existingRapidApiKey = rapidApiMatch[1];
    }
  }

  const envContent = `# Auto-generated by deployV4.js - ${new Date().toISOString()}
# Network: ${hre.network.name} (Chain ID: ${chainId})

RPC_URL=${getRpcUrl(hre.network.name)}
PRIVATE_KEY=${existingPrivateKey}

# Contract Addresses (V4)
PREDICTION_MARKET_ADDRESS=${predictionAddress}
CREATOR_MARKET_ADDRESS=${creatorAddress}
USDC_ADDRESS=${usdcAddress}

# Contract Versions
PREDICTION_MARKET_VERSION=4
CREATOR_MARKET_VERSION=3

RAPIDAPI_KEY=${existingRapidApiKey}
RAPIDAPI_HOST=twitter241.p.rapidapi.com

PORT=3001
`;

  try {
    fs.writeFileSync(oracleEnvPath, envContent);
    console.log("âœ… Updated oracle-node/.env");
    
    fs.writeFileSync(path.join(oracleDir, ".env.example"), envContent);
    console.log("âœ… Updated oracle-node/.env.example");
  } catch (error) {
    console.log("âš ï¸ Could not update oracle .env:", error.message);
  }

  // æ‰“å°æ€»ç»“
  console.log("\n" + "=".repeat(60));
  console.log("ðŸŽ‰ ALL CONTRACTS DEPLOYED SUCCESSFULLY!");
  console.log("=".repeat(60));
  console.log("\nðŸ“‹ Contract Addresses:");
  console.log("   MockUSDC:            ", usdcAddress);
  console.log("   PredictionMarketV4:  ", predictionAddress);
  console.log("   CreatorMarketV3:     ", creatorAddress);
  console.log("\nðŸŒ Network Info:");
  console.log("   Network:  ", hre.network.name);
  console.log("   Chain ID: ", chainId);
  console.log("   Deployer: ", deployer.address);
  console.log("\nðŸ†• New Features in V4:");
  console.log("   ðŸ“Š PredictionMarket: CPMM + LMSR åŒå®šä»·ç®—æ³•");
  console.log("   ðŸ“ˆ CreatorMarket: Linear/Exponential/Sigmoid å¤šæ›²çº¿");
  console.log("=".repeat(60));

  // 7. éªŒè¯æç¤º
  console.log("\nðŸ“ Next Steps:");
  console.log("   1. æ›´æ–°å‰ç«¯ hooks ä»¥æ”¯æŒæ–°çš„åˆçº¦ ABI");
  console.log("   2. å¦‚æžœåœ¨æµ‹è¯•ç½‘ï¼Œå¯ä»¥è¿è¡ŒéªŒè¯è„šæœ¬:");
  console.log(`      npx hardhat verify --network ${hre.network.name} ${predictionAddress} ${usdcAddress}`);
  console.log(`      npx hardhat verify --network ${hre.network.name} ${creatorAddress} ${usdcAddress}`);
  console.log("   3. æµ‹è¯•æ–°åŠŸèƒ½:");
  console.log("      - åˆ›å»º LMSR ç®—æ³•çš„é¢„æµ‹å¸‚åœº");
  console.log("      - åˆ›å»ºä½¿ç”¨æŒ‡æ•°/Sigmoid æ›²çº¿çš„åˆ›ä½œè€…");
}

function getRpcUrl(networkName) {
  const rpcUrls = {
    sepolia: "https://eth-sepolia.g.alchemy.com/v2/BVg93ArKlmUQFHzHqureN",
    baseSepolia: "https://sepolia.base.org",
    base: "https://mainnet.base.org",
    mainnet: "https://eth-mainnet.g.alchemy.com/v2/YOUR_KEY",
    localhost: "http://127.0.0.1:8545"
  };
  return rpcUrls[networkName] || "https://sepolia.base.org";
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});